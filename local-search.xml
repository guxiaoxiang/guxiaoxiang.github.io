<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>快乐数</title>
    <link href="/2024/10/10/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <url>/2024/10/10/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>编写一个算法来判断一个数是不是快乐数。</p><p>「快乐数」定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。</li><li>如果这个过程结果为1，那么这个数就是快乐数。</li></ul><p>如果n是快乐数就返回true;不是，则返回false。</p><p><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">示例 1：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：n = 19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1<br></code></pre></td></tr></table></figure><p><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">示例 2：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：n = 2<br>输出：false<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">10</span>;<br>            n = n / <span class="hljs-number">10</span>;<br>            totalSum += d * d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalSum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span> &amp;&amp; !seen.contains(n)) &#123;<br>            seen.add(n);<br>            n = getNext(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合Knief4j</title>
    <link href="/2024/10/10/SpringBoot%E6%95%B4%E5%90%88Knief4j/"/>
    <url>/2024/10/10/SpringBoot%E6%95%B4%E5%90%88Knief4j/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot整合Knief4j"><a href="#SpringBoot整合Knief4j" class="headerlink" title="SpringBoot整合Knief4j"></a>SpringBoot整合Knief4j</h2><blockquote><p><strong>本文SpringBoot版本为2.6，版本不同操作可能会有不同</strong></p></blockquote><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加swagger的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-Knief4j配置类"><a href="#2-Knief4j配置类" class="headerlink" title="2.Knief4j配置类"></a>2.Knief4j配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2WebMvc</span><br><span class="hljs-meta">@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(value = &quot;defaultApi2&quot;)</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">defaultApi2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .select()<br>                <span class="hljs-comment">// 这里一定要标注你控制器的位置</span><br>             .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;org.lostarknotespring.controller&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>    &#125;<br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;项目名称&quot;</span>)<br>                .description(<span class="hljs-string">&quot;项目名称接口文档&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3.配置文件"></a>3.配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ant_path_matcher</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot+Vue3项目实战</title>
    <link href="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <url>/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="项目准备与配置"><a href="#项目准备与配置" class="headerlink" title="项目准备与配置"></a>项目准备与配置</h2><h3 id="数据库以及其他项目配置"><a href="#数据库以及其他项目配置" class="headerlink" title="数据库以及其他项目配置"></a>数据库以及其他项目配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9090</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/lostarknote</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guxiang</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>遇到问题：</strong><em>找不到”url”….</em><br><strong>可能原因：</strong><em>没有扫描到配置文件（yml），在pom.xml中的build标签中添加以下内容</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a name="wZP2h"></a></p><h3 id="启动类相关"><a href="#启动类相关" class="headerlink" title="启动类相关"></a>启动类相关</h3><p>@SpringBootApplication:包扫描时，自动扫描启动类所在包及其子包，若需要扫描其他包，需要使用@ComponentScan进行包名指定 </p><h3 id="Lombok工具："><a href="#Lombok工具：" class="headerlink" title="Lombok工具："></a>Lombok工具：</h3><p>自动生成getter&#x2F;setter&#x2F;toString方法 ，需要引入lombok依赖，然后在实体类上添加@Data注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Result实体类"><a href="#Result实体类" class="headerlink" title="Result实体类"></a>Result实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-keyword">private</span> T data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; Result&lt;E&gt; <span class="hljs-title function_">success</span><span class="hljs-params">(E data)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;&gt;(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;操作成功&quot;</span>,data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;操作成功&quot;</span>,<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,message,<span class="hljs-literal">null</span>);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h2><h3 id="注册功能："><a href="#注册功能：" class="headerlink" title="注册功能："></a>注册功能：</h3><h4 id="1-密码加密"><a href="#1-密码加密" class="headerlink" title="1.密码加密"></a>1.密码加密</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MD5Util</span> &#123;<br>    <span class="hljs-comment">//生成MD5</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getMD5</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">md5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;MD5&quot;</span>);  <span class="hljs-comment">// 创建一个md5算法对象</span><br>            <span class="hljs-type">byte</span>[] messageByte = message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            <span class="hljs-type">byte</span>[] md5Byte = md.digest(messageByte);              <span class="hljs-comment">// 获得MD5字节数组,16*8=128位</span><br>            md5 = bytesToHex(md5Byte);                            <span class="hljs-comment">// 转换为16进制字符串</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> md5;<br>    &#125;<br><br>    <span class="hljs-comment">// 二进制转十六进制</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">bytesToHex</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">hexStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-type">int</span> num;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bytes.length; i++) &#123;<br>            num = bytes[i];<br>            <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>) &#123;<br>                num += <span class="hljs-number">256</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">16</span>)&#123;<br>                hexStr.append(<span class="hljs-string">&quot;0&quot;</span>);<br>            &#125;<br>            hexStr.append(Integer.toHexString(num));<br>        &#125;<br>        <span class="hljs-keyword">return</span> hexStr.toString().toUpperCase();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-参数校验——Spring-Validation"><a href="#2-参数校验——Spring-Validation" class="headerlink" title="2.参数校验——Spring Validation"></a>2.参数校验——Spring Validation</h4><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724488370258-2fff5ce4-4b4f-4f36-9081-9bc37070d6bb.png"></p><h4 id="3-全局异常处理器"><a href="#3-全局异常处理器" class="headerlink" title="3.全局异常处理器"></a>3.全局异常处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">handleException</span><span class="hljs-params">(Exception e)</span><br>    &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> Result.error(StringUtils.hasLength(e.getMessage())? e.getMessage() : <span class="hljs-string">&quot;操作失败！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><h4 id="登录认证：JWT令牌"><a href="#登录认证：JWT令牌" class="headerlink" title="登录认证：JWT令牌"></a>登录认证：JWT令牌</h4><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724489556568-920ef5bd-8334-41de-973d-78709796c5ad.png"></p><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724489761881-ba8ccc2c-8a2c-42c8-ad50-b3e93cbd0460.png"></p><h4 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SECRET</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;guxiang&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateToken</span><span class="hljs-params">(Map&lt;String, Object&gt; claims)</span>&#123;<br>        <span class="hljs-keyword">return</span> JWT.create()<br>                .withClaim(<span class="hljs-string">&quot;claims&quot;</span>, claims)<br>                .withExpiresAt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis()* <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>))<br>                .sign(Algorithm.HMAC256(SECRET));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; <span class="hljs-title function_">parseToken</span><span class="hljs-params">(String token)</span>&#123;<br>        <span class="hljs-keyword">return</span> JWT.require(Algorithm.HMAC256(SECRET))<br>                .build()<br>                .verify(token)<br>                .getClaim(<span class="hljs-string">&quot;claims&quot;</span>)<br>                .asMap();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="IzFyP"></a></p><h4 id="JWT验证：从请求头中获取token"><a href="#JWT验证：从请求头中获取token" class="headerlink" title="JWT验证：从请求头中获取token"></a>JWT验证：从请求头中获取token</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/dungeon&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DungeonController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(&quot;Authorization&quot;)</span> String token, HttpServletResponse response)</span> &#123;<br>        <span class="hljs-comment">//验证token</span><br>        <span class="hljs-comment">//若能正常解析（不报错），则验证通过</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Map&lt;String, Object&gt; claims = JWTUtil.parseToken(token);<br>            <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;副本数据获取成功！&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;未登录！&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="zx8k2"></a></p><h4 id="进阶：注册拦截器进行验证。"><a href="#进阶：注册拦截器进行验证。" class="headerlink" title="进阶：注册拦截器进行验证。"></a>进阶：注册拦截器进行验证。</h4><p>注册一个拦截器进行token的验证，就不用单独在每个业务代码里进行token验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//令牌验证</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br><br>        <span class="hljs-comment">//若能正常解析（不报错），则验证通过</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Map&lt;String, Object&gt; claims = JWTUtil.parseToken(token);<br>            <span class="hljs-comment">//放行</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//登录注册不用拦截</span><br>        registry.addInterceptor(loginInterceptor).excludePathPatterns(<span class="hljs-string">&quot;/user/login&quot;</span>,<span class="hljs-string">&quot;/user/register&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/dungeon&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DungeonController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//这里不用再验证token，已经统一在拦截器中做验证</span><br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;副本数据获取成功！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="CPLzv"></a></p><h4 id="登录优化——Redis"><a href="#登录优化——Redis" class="headerlink" title="登录优化——Redis"></a>登录优化——Redis</h4><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724726267565-351696e4-6933-46fc-917f-64ff425ea432.png"></p><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724726416408-be6d8fb1-7f06-474d-9b95-8319c95d3047.png"></p><h3 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h3><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><ul><li>获取用户信息需要通过token中存储的username到数据库中查找，需要解析token。</li><li>在其他业务可能也需要username的信息，又要解析token，为了避免代码重复，在之前拦截器中解析出的token统一放到线程中（ThreadLocal）。</li></ul><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724491870223-7d0ab1ec-7a6e-48c4-8e01-b58743ec88cf.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalUtil</span> &#123;<br><br>    <span class="hljs-comment">//提供ThreadLocal对象</span><br>    private <span class="hljs-keyword">static</span> final <span class="hljs-title class_">ThreadLocal</span> <span class="hljs-variable constant_">THREAD_LOCAL</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br>    public <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (T) <span class="hljs-variable constant_">THREAD_LOCAL</span>.<span class="hljs-title function_">get</span>();<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> value</span>) &#123;<br>        <span class="hljs-variable constant_">THREAD_LOCAL</span>.<span class="hljs-title function_">set</span>(value);<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable constant_">THREAD_LOCAL</span>.<span class="hljs-title function_">remove</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器中将数据存入ThreadLocal中，请求完成后清除ThreadLocal，防止内存泄露</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//令牌验证</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br><br><br><br>        <span class="hljs-comment">//若能正常解析（不报错），则验证通过</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Map&lt;String, Object&gt; claims = JWTUtil.parseToken(token);<br>            <span class="hljs-comment">//将数据存储到ThreadLocal中</span><br>            ThreadLocalUtil.set(claims);<br>            <span class="hljs-comment">//放行</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//清空ThreadLocal中的数据，防止内存泄露</span><br>        ThreadLocalUtil.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口中从ThreadLocal中获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/userInfo&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title function_">userInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(&quot;Authorization&quot;)</span> String token)</span> &#123;<br><span class="hljs-comment">//        Map&lt;String, Object&gt; claims = JWTUtil.parseToken(token);</span><br><span class="hljs-comment">//        String username = (String) claims.get(&quot;username&quot;);</span><br><br>        Map&lt;String, Object&gt; map = ThreadLocalUtil.get();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String) map.get(<span class="hljs-string">&quot;username&quot;</span>);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">loginUser</span> <span class="hljs-operator">=</span> userService.findByUsername(username);<br><br>        <span class="hljs-keyword">return</span> Result.success(loginUser);<br>    &#125;<br></code></pre></td></tr></table></figure><p><a name="XYgaC"></a></p><h4 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a>@JsonIgnore</h4><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724491443923-60b7f0f7-1830-4b37-ac0d-463cc4054091.png"></p><h3 id="更新用户信息"><a href="#更新用户信息" class="headerlink" title="更新用户信息"></a>更新用户信息</h3><h4 id="实体类中参数验证"><a href="#实体类中参数验证" class="headerlink" title="实体类中参数验证"></a>实体类中参数验证</h4><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724493311830-36c13ab6-ab03-4d4b-a3c2-1feffe42d2eb.png"></p><h3 id="更新用户密码"><a href="#更新用户密码" class="headerlink" title="更新用户密码"></a>更新用户密码</h3><p>参数用一个map接收，因为接受的参数名与数据库中不一致<br>更新用户信息时，参数名与字段名一致，所以用user实体类接收<br><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724493923725-46d7e988-17dc-4f9e-a9eb-1c3f5903a6d0.png"></p><h2 id="文章模块"><a href="#文章模块" class="headerlink" title="文章模块"></a>文章模块</h2><h3 id="新增文章分类"><a href="#新增文章分类" class="headerlink" title="新增文章分类"></a>新增文章分类</h3><h3 id="文章分类列表"><a href="#文章分类列表" class="headerlink" title="文章分类列表"></a>文章分类列表</h3><h4 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a>@JsonFormat</h4><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724679349182-f53100b5-2caf-4d90-9cfd-042ef4b14959.png"></p><h3 id="文章分类详情"><a href="#文章分类详情" class="headerlink" title="文章分类详情"></a>文章分类详情</h3><p><a name="k8q0e"></a></p><h3 id="更新文章分类"><a href="#更新文章分类" class="headerlink" title="更新文章分类"></a>更新文章分类</h3><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724680351712-f2e307a6-5874-4c28-b070-6a1527c03e6b.png"></p><h3 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h3><p><a name="bDD4z"></a></p><h4 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h4><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724719296719-aba8d69b-d381-4f3f-8ba1-73c49c79816f.png"></p><h3 id="文章分页查询"><a href="#文章分页查询" class="headerlink" title="文章分页查询"></a>文章分页查询</h3><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724720216592-e3548263-016c-4a8c-b007-27210f9bc731.png"></p><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724720365010-4ff7382b-e85c-4f6b-82e7-4bf81bbc2f75.png" alt="image.png"></p><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724720426641-af539793-2c2b-4302-93e7-8d86af685a69.png" alt="image.png"></p><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724720549882-4af8332e-ec49-482e-987c-a94abc19572b.png" alt="image.png"></p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><img src="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1724722208238-5ceb4e03-92ee-4878-b928-c30a97225967.png" alt="image.png"></p><h3 id><a href="#" class="headerlink" title></a><br></h3>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java八股——基础篇</title>
    <link href="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="uc3Ar">基本数据类型与包装类</h2><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="基本数据类型"></p><h3 id="gYvgU">基本数据类型与引用数据类型区别</h3><ul><li><p>存储方式：基本数据类型直接<strong>存储值</strong>，而引用数据类型存储的是对象的引用（<strong>内存地址</strong>）</p></li><li><p>内存分配：基本数据类型在<strong>栈</strong>上分配内存，引用数据类型在<strong>堆</strong>上分配内存（_具体内容存放在堆中，栈中存放的是其具体内容所在内存的地址_）。栈上的分配速度较快，但是内存空间较小，而堆上的分配速度较慢，但可以分配更大的内存空间</p></li><li><p>默认值：基本数据类型会<strong>有默认值</strong>，例如int类型的默认值是0，boolean类型的默认值是false。而引用数据类型的默认值<strong>是null</strong>，表示没有引用指向任何对象</p></li><li><p>参数传递：基本数据类型作为方法的参数传递时，<strong>传递的是值的副本</strong>，不会修改原始值。而引用数据类型作为方法的参数传递时，传递的是对象的引用，<strong>可以修改对象的属性或状态</strong></p></li><li><p>比较操作：基本数据类型使用进行比较时，比较的是<strong>值是否相等</strong>。而引用数据类型使用&#x3D;&#x3D;进行比较时，比较的是引用是否指向同一个对象（<strong>地址</strong>），如果要比较对象的内容是否相同，需要使用<strong>equals()方法</strong></p></li></ul><p>注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong>基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是<strong>局部变量</strong>，那么它们会存放在<strong>栈中</strong>；如果它们是<strong>成员变量</strong>，那么它们会存放在<strong>堆中</strong>。</p><h3 id="hpaQX">包装类型的缓存机制</h3><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>两种浮点数类型的包装类 <strong>Float</strong> ,<strong>Double</strong>并没有实现缓存机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于Integer类型的缓存机制，且33在-128-127之间，所以他们比较的相当于是常量的值</span><br><span class="hljs-comment">//而Float，Double没有缓存机制，所以他们相当于比较的是两个对象的地址</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br>System.out.println(i1 == i2);<span class="hljs-comment">// 输出 true</span><br><br><span class="hljs-type">Float</span> <span class="hljs-variable">i11</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br><span class="hljs-type">Float</span> <span class="hljs-variable">i22</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>System.out.println(i11 == i22);<span class="hljs-comment">// 输出 false</span><br><br><span class="hljs-type">Double</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br><span class="hljs-type">Double</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>System.out.println(i3 == i4);<span class="hljs-comment">// 输出 false</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。</span><br><span class="hljs-comment">//因此，i1 直接使用的是缓存中的对象。而Integer i2 = new Integer(40) 会直接创建新的对象。</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">40</span>);<br>System.out.println(i1==i2);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</strong></p><h2 id="bQZbZ">浮点数计算会丢失精度？</h2>因为Java中不是所有小数都能用二进制表示，浮点数只是近似值，不是精确值。Java中提供BigDecimal进行精确运算。<p>小数二进制表示方法：例如0.625，将小数不断乘2，取整数部分</p><p>0.625*2 &#x3D; 1.25——————1</p><p>0.25*2   &#x3D; 0.5  ——————0</p><p>0.5*2     &#x3D; 1     ——————1</p><p>所以0.625二进制表示为0.101</p><p>但例如0.2则无法表示</p><p>BigDecimal可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过BigDecimal来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a.subtract(c);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b.subtract(c);<br><br>System.out.println(x); <span class="hljs-comment">/* 0.2 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.20 */</span><br><span class="hljs-comment">// 比较内容，不是比较值</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* false */</span><br><span class="hljs-comment">// 比较值相等用相等compareTo，相等返回0</span><br>System.out.println(<span class="hljs-number">0</span> == x.compareTo(y)); <span class="hljs-comment">/* true */</span><br></code></pre></td></tr></table></figure><h2 id="nNTkk">变量相关</h2><h3 id="JB0Ih">成员变量与局部变量</h3><ul><li><p><strong>语法形式</strong>：从语法形式上看，成员变量是<strong>属于类</strong>的，而局部变量是在<strong>代码块或方法中</strong>定义的变量或是方法的参数；成员变量可以被 <strong>public</strong>,<strong>private</strong>,<strong>static</strong> 等修饰符所修饰，而局部变量<strong>不能被访问控制修饰符及 static所修饰</strong>；但是，成员变量和局部变量<strong>都能被 final所修饰</strong>。</p></li><li><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是<strong>属于类的</strong>，如果没有使用 <code>static</code> 修饰，这个成员变量是<strong>属于实例的</strong>。而_对象存在于堆内存，局部变量则存在于栈内存。_</p></li><li><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它<strong>随着对象的创建而存在</strong>，而局部变量_随着方法的调用而自动生成，随着方法的调用结束而消亡_。</p></li><li><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会<strong>自动以类型的默认值而赋值</strong>（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局<strong>部变量则不会自动赋值</strong>。</p></li></ul><h3 id="mYOVl">静态变量</h3><p>静态变量也就是被 <code>static</code> 关键字修饰的变量。它可以<strong>被类的所有实例共享</strong>，无论一个类创建了多少个对象，它们都<strong>共享同一份静态变量</strong>。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p><p>静态变量是<strong>通过类名来访问</strong>的，例如<code>StaticVariableExample.staticVar</code>（如果被 <code>private</code>关键字修饰就无法这样访问了）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticVariableExample</span> &#123;<br>    <span class="hljs-comment">// 静态变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通常情况下，静态变量会<strong>被</strong>final<strong>关键字修饰成为常量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantVariableExample</span> &#123;<br>    <span class="hljs-comment">// 常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">constantVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="nwil5">静态方法为什么不能调用非静态成员？</h2><ul><li><p>静态方法是<strong>属于类的</strong>，在<strong>类加载的时候就会分配内存</strong>，可以通过类名直接访问。而非静态成员<strong>属于实例对象</strong>，只有在对象<strong>实例化之后才存在</strong>，需要通过类的实例对象去访问。</p></li><li><p>_在类的非静态成员不存在的时候静态方法就已经存在了_，此时调用在内存中还不存在的非静态成员，属于非法操作。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-comment">// 定义一个字符型常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">LETTER_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>    <span class="hljs-comment">// 定义一个字符串常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">GREETING_MESSAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 输出字符型常量的值</span><br>        System.out.println(<span class="hljs-string">&quot;字符型常量的值为：&quot;</span> + LETTER_A);<br><br>        <span class="hljs-comment">// 输出字符串常量的值</span><br>        System.out.println(<span class="hljs-string">&quot;字符串常量的值为：&quot;</span> + GREETING_MESSAGE);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="c2WL2">静态方法和实例方法有何不同？</h3><h4 id="v1GQp">1、调用方式</h4><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staicMethod</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 调用实例方法</span><br>        person.method();<br>        <span class="hljs-comment">// 调用静态方法</span><br>        Person.staicMethod()<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="r4XcA">2、访问类成员是否存在限制</h4>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。<h2 id="UDqVC">重载与重写</h2><h3 id="H6pnJ">重载</h3><p>发生在<strong>同一个类中（或者父类和子类之间）</strong>，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同（<strong>仅要求方法名相同</strong>）。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><h3 id="yviDa">重写</h3><p>重写发生<strong>在运行期</strong>，是<strong>子类对父类的允许访问的方法</strong>的实现过程进行<strong>重新编写</strong>。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p><strong>方法的重写要遵循“两同两小一大”</strong>：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的_返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。_</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级英雄&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超人&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Hero <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperSuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperMan</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级超级英雄&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SuperMan <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMan</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="ZpXrF">面向对象三大特征</h2><h3 id="VR77A">封装</h3><p> 封装是指把_<strong>一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息</strong><em>。但是可以</em><strong>提供一些可以被外界访问的方法来操作属性</strong>_。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//id属性私有化</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//name属性私有化</span><br><br>    <span class="hljs-comment">//获取id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-comment">//设置id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-comment">//获取name的方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-comment">//设置name的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="ci6hw">继承</h3><p> 不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是<strong>使用已存在的类的定义作为基础建立新类的技术</strong>，新类的定义_可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类_。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问。</li><li>子类<strong>可以拥有自己属性和方法</strong>，即子类可以对父类进行扩展。</li><li>子类<strong>可以用自己的方式实现父类的方法</strong>。（以后介绍）。</li></ol><h3 id="m1PMP">多态</h3>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。<p><strong>多态的特点:</strong></p><ul><li><strong>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系</strong>；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><h2 id="Pgghw">接口和抽象类的区别</h2><h3 id="BDZ8B">共同点</h3><ul><li><strong>实例化</strong>：接口和抽象类都<strong>不能直接实例化</strong>，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。</li><li><strong>抽象方法</strong>：接口和抽象类都<strong>可以包含抽象方法</strong>。<em>抽象方法没有方法体，必须在子类或实现类中实现。</em></li></ul><h3 id="tYoOr">区别</h3><ul><li><p><strong>设计目的</strong>：接口主要用于<strong>对类的行为进行约束</strong>，你实现了某个接口就具有了对应的行为。抽象类主要<strong>用于代码复用</strong>，强调的是所属关系。</p></li><li><p><strong>继承和实现</strong>：一个类<strong>只能继承一个类（包括抽象类）</strong>，因为 Java 不支持多继承。但一个类可以<strong>实现多个接口</strong>，一个接口也可以继承多个其他接口。</p></li><li><p><strong>成员变量</strong>：接口中的<strong>成员变量只能是 public static final 类型的</strong>，不能被修改且<strong>必须有初始值</strong>。抽象类的成员变量<strong>可以有任何修饰符</strong>（<code>private</code>, <code>protected</code>, <code>public</code>），可以在子类中被重新定义或赋值。</p></li><li><p><strong>方法</strong>： </p><ol><li><p>Java 8 之前，接口中的方法<strong>默认是 public abstract <strong>，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 <strong>default（默认） 方法和 static（静态）方法</strong>。Java 8 引入的static方法无法在实现类中被覆盖，只能通过接口名直接调用，类似于类中的静态方法。static方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。自 Java 9 起，接口</strong>可以包含 private 方法</strong>。private方法可以用于在接口内部共享代码，不对外暴露。</p></li><li><p>抽象类<strong>可以包含抽象方法和非抽象方法</strong>。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</p></li></ol></li></ul><h2 id="jTwOr">深拷贝和浅拷贝</h2><ul><li><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p></li><li><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p></li></ul><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt="深拷贝与浅拷贝"></p><h2 id="LnHfA">hashCode()和equals()</h2><h3 id="FnNW4">equals()</h3><p><code>equals()</code> 不能用于判断基本数据类型的变量，<strong>只能用来判断两个对象是否相等</strong>。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此<strong>所有的类都有equals()方法。</strong></p><p><strong>String</strong>中的<strong>equals</strong>方法是被重写过的<strong>，比较的是 String 字符串的值是否相等。 Object</strong>的<strong>equals方法是比较的对象的内存地址。</strong></p><h3 id="UVHmC">hashCode()</h3><p>hashCode()的作用是<strong>获取哈希码</strong>（int整数），也称为散列码。这个哈希码的作用是<strong>确定该对象在哈希表中的索引位置。</strong></p><p>其实，hashCode() 和 equals()<strong>都是用于比较两个对象是否相等</strong>。</p><p>总结下来就是：</p><ul><li><p>如果两个对象的hashCode值相等，那这两个对象不一定相等（哈希碰撞）。</p></li><li><p>如果两个对象的hashCode值相等并且equals()方法也返回true，我们才认为这两个对象相等。</p></li><li><p>如果两个对象的hashCode值不相等，我们就可以直接认为这两个对象不相等。</p></li></ul><h2 id="UGgnZ">String、StringBuffer、StringBuilder 的区别</h2><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/String%E7%9B%B8%E5%85%B3.png" alt="String相关"></p><h3 id="esGci">可变性</h3><p><code>String</code> <strong>是不可变的</strong>（后面会详细分析原因）。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><h3 id="jcgb3">线程安全</h3><p><code>String</code> 中的对象是不可变的，也就<strong>可以理解为常量，线程安全</strong>。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全的</strong></p><h3 id="L5JlZ">性能</h3><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="String常用方法"></p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/String%E5%B0%8F%E7%BB%93.png" alt="String小结"></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/27509659/1715667356881-b30de396-12ef-425f-ab02-37e2eb705816.png"></p><h3 id="ZWdar">对于三使用的总结：</h3><ul><li><p>操作少量的数据: 适用String</p></li><li><p>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</p></li><li><p>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p></li></ul><h3 id="FrKXG">String为什么不可变？</h3><ul><li><p>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</p></li><li><p><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p></li></ul><h3 id="TLC70">String s1 = new String("abc");这句话一个创建几个对象？</h3><p><strong>字符串常量池</strong>是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是<strong>为了避免字符串的重复创建</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><br><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><h3 id="BLnpB">String.intern()</h3><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p><ul><li><p>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</p></li><li><p>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”Java“</span><br><span class="hljs-comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br><span class="hljs-comment">// 会在堆中在单独创建一个字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s3.intern();<br><span class="hljs-comment">// s1 和 s2 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// s3 和 s4 指向的是堆中不同的对象</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// s1 和 s4 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s4); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于编译器的优化，&quot;str&quot; + &quot;ing&quot;会被优化为&quot;string&quot;</span><br><span class="hljs-comment">//而str1 + str2为引用类型，引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<span class="hljs-comment">//在堆上创建的新对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br>System.out.println(str3 == str5);<span class="hljs-comment">//true</span><br>System.out.println(str4 == str5);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="yqKHg">Exception和Error</h2><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/Exception%E5%92%8CError.png" alt="Exception和Error"></p><h3 id="WyNGk">区别</h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><p><strong>Exception</strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p></li><li><p><strong>Error</strong>：<code>Error</code> 属于程序无法处理的错误 ，<del>我们没办法通过 ~~&#96;</del>catch<del>&#96;</del> 来进行捕获~~不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p></li></ul><h3 id="gHxJC">checked Exception和unchecked Exception的区别</h3><p><strong>Checked Exception</strong>即受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被catch或者throws关键字处理的话，就没办法通过编译。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException…</p><p><strong>Unchecked Exception</strong>即<strong>不受检查异常</strong>，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p>RuntimeException 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误比如方法入参类型错误)</li><li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>ArithmeticException（算术错误）</li><li>SecurityException（安全错误比如权限不够）</li><li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li></ul><h3 id="qOPQF">finally中的代码一定会执行吗？</h3>不一定的！在某些情况下，finally 中的代码不会被执行。<p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>    <span class="hljs-comment">// 终止当前正在运行的Java虚拟机</span><br>    System.exit(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Try to do something<br>Catch Exception -&gt; RuntimeException<br></code></pre></td></tr></table></figure><p>另外，在以下 2 种特殊情况下，finally块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><h2 id="ZRSXT">泛型</h2>泛型（通过类型擦除实现）允许在定义类或接口的时候使用类型参数，声明的类型参数在使用的时候用具体的类型来替换。<p>好处：</p><p>1.方便：例如定义Integer和String的List，不使用泛型，则需定义两个List<Integer>和List<String>，使用泛型则只需定义一个List<T></T></String></Integer></p><p>2.安全：没有泛型的使用，使用Object实现的类型转换会在运行时进行检查，类型转换出错，整个程序挂掉。使用泛型，则会在编译器进行检查，提高代码的安全性。</p><p>类型擦除：是Java处理泛型的一种方式，从泛型类型中擦除类型参数的相关信息，并在必要的时候添加类型检查和类型转换的方法。简单理解为，将泛型Java代码转换为普通Java代码。</p><h4 id="TklUq">泛型使用方式</h4><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p>1.泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//实例化泛型类</span><br>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure><p>2.泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//实现泛型接口，不指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//实现泛型接口，指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; E &gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">( E[] inputArray )</span><br>&#123;<br>     <span class="hljs-keyword">for</span> ( E element : inputArray )&#123;<br>        System.out.printf( <span class="hljs-string">&quot;%s &quot;</span>, element );<br>     &#125;<br>     System.out.println();<br>&#125;<br><br><span class="hljs-comment">// 创建不同类型数组：Integer, Double 和 Character</span><br>Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>String[] stringArray = &#123; <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br>printArray( intArray  );<br>printArray( stringArray  );<br></code></pre></td></tr></table></figure><h2 id="XVX2u">反射</h2>反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有属性和方法。<p>Java的反射可以：</p><ol><li>在运行时判断任意一个对象所属的类。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时任意调用一个对象的方法</li><li>在运行时构造任意一个类的对象</li></ol><p>反射的好处就是可以提升程序的灵活性和扩展性，比较容易在运行期干很多事情。但是他带来的问题更多，主要由以下几个：</p><ol><li>代码可读性低及可维护性</li><li>反射代码执行的性能低</li><li>反射破坏了封装性</li></ol><p>所以，我们应该在业务代码中应该尽量避免使用反射。但是，作为一个合格的ava开发，也要能读懂中间件、框架中的反射代码。在有些场景下，要知道可以使用反射解决部分问题。</p><h3 id="phzBG">反射和class的关系</h3>Java的Class类是java反射机制的基础，通过Class类我们可以获得关于一个类的相关信息<p>java.lang.Class是一个比较特殊的类，它用于封装被装入到VM中的类（包括类和接口)的信息。当一个类或接口被装入到JVM时便会产生一个与之关联的java.lang.Class对象，可以通过这个Class对象对被装入类的详细信息进行访问。</p><p>虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的<Class>对象是否已经加载。如果没有加载，JVM就会根据类名查找.class.文件，并将其Class对象载入。</Class></p><h3 id="cQeis">反射为什么慢？</h3><ol><li><p>由于反射涉及动态解析的类型，因此不能执行某些java虚拟机优化，如JIT优化。</p></li><li><p>在使用反射时，参数需要包装(boxing)成Object()类型，但是真正方法执行的时候，又需要再拆包(unboxing)成真正的类型，这些动作不仅消耗时间，而且过程中也会产生很多对象，对象一多就容易导致GC，GC也会导致应用变慢。</p></li><li><p>反射调用方法时会从方法数组中遍历查找，并且会检查可见性。这些动作都是耗时的。</p></li><li><p>不仅方法的可见性要做检查，参数也需要做很多额外的检查。</p></li></ol><h2 id="iNiGN">序列化和反序列化</h2>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。<p>简单来说：</p><ul><li><p><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</p></li><li><p><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</p></li></ul><h3 id="sbsE2">序列化协议在TCP/IP4层模型的哪一层？</h3><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/tcp4%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="tcp4层模型"></p><p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p><p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议应用层的一部分。</p><p>另外，用于序列化和反序列化的类必须实现 Serializable 接口，对象中如果有属性不想被序列化，使用 transient 修饰。</p><h2 id="YwQSn">I/O</h2><p> IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><p><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p></li><li><p><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p></li></ul><h3 id="UaN6B">字节流</h3><h4 id="K6u6l">InputStream</h4>InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。<p>FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Number of remaining bytes:&quot;</span><br>            + fis.available());<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fis.skip(<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">Number of remaining bytes:11<br>The actual number of bytes skipped:2<br>The content read from file:JavaGuide<br></code></pre></td></tr></table></figure><p>不过，一般我们是不会直接单独使用 FileInputStream，通常会配合BufferedInputStream（字节缓冲输入流，后文会讲到）来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br><span class="hljs-comment">// 读取文件的内容并复制到 String 对象中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufferedInputStream.readAllBytes());<br>System.out.println(result);<br></code></pre></td></tr></table></figure><h4 id="ZzClQ">OutputStream</h4>OutputStream用于将数据（字节信息）写入到目的地（通常是文件），java.io.OutputStream抽象类是所有字节输出流的父类。<p>FileOutputStream是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-string">&quot;JavaGuide&quot;</span>.getBytes();<br>    output.write(array);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>类似于 FileInputStream，FileOutputStream 通常也会配合 BufferedOutputStream（字节缓冲输出流，后文会讲到）来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fileOutputStream)<br></code></pre></td></tr></table></figure><h3 id="MpbAx">字符流</h3><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>个人认为主要有两点原因：</p><ul><li><p>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</p></li><li><p>如果我们不知道编码类型就很容易出现乱码问题</p></li></ul><p>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p><h4 id="ok7Ye">Reader</h4>Reader用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是所有字符输入流的父类。<p>Reader用于读取文本，InputStream 用于读取原始字节。</p><p>InputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节流转换为字符流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于读取字符文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStreamReader</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);) &#123;<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fileReader.skip(<span class="hljs-number">3</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="MziG5">Writer</h4>Writer用于将数据（字符信息）写入到目的地（通常是文件），java.io.Writer抽象类是所有字符输出流的父类。<p>OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装，可以直接将字符写入到文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符流转换为字节流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于写入字符到文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OutputStreamWriter</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Writer</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>    output.write(<span class="hljs-string">&quot;你好，我是Guide。&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mSWQU">字节缓冲流</h3>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。<p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。 如果是调用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</p><h3 id="c4Y9J">BufferedInputStream</h3><p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p><p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 <code>BufferedInputStream</code> 源码即可得到这个结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br>    <span class="hljs-comment">// 内部缓冲区数组</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">byte</span> buf[];<br>    <span class="hljs-comment">// 缓冲区的默认大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>;<br>    <span class="hljs-comment">// 使用默认的缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>    &#125;<br>    <span class="hljs-comment">// 自定义缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>        &#125;<br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓冲区的大小默认为<strong>8192</strong> 字节，当然了，你也可以通过 BufferedInputStream(InputStream in, int size)这个构造方法来指定缓冲区的大小。</p><h3 id="LD0oA">BufferedOutputStream</h3><p><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))) &#123;<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-string">&quot;JavaGuide&quot;</span>.getBytes();<br>    bos.write(array);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>类似于BufferedInputStream ，BufferedOutputStream 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <strong>8192</strong> 字节。</p>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java八股——SpringBoot篇</title>
    <link href="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/"/>
    <url>/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="dlN81">前置知识</h2><h3 id="u6xLT">ApplicationContextInitializer</h3>ApplicationContextInitializer是Spring框架中的一个扩展接口，用于在应用程序上下文（ApplicationContext）创建之前对其进行自定义初始化。通过实现该接口，您可以在应用程序上下文启动之前执行一些额外的配置或准备工作。<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187627897-b413ec69-2287-4a4b-810f-fc33c3210559.png"></p><h4 id="mQPOk">应用场景</h4><ul><li>动态加载配置：通过实现ApplicationContextInitializer，您可以在应用程序上下文创建之前加载一些动态的配置，例如从外部配置文件中读取配置信息并注入到Spring的环境中。</li><li>执行额外的初始化逻辑：如果您有一些需要在应用程序上下文启动之前执行的初始化逻辑，例如初始化<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>连接池或启动一些后台任务，您可以通过实现ApplicationContextInitializer来实现这些逻辑。</li></ul><h4 id="baXim">使用方式</h4>1.定义ApplicationContextInitializer的实现类MyApplicationContextInitializer，进行属性注入<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span>&#123;<br>    <span class="hljs-comment">//ioc容器对象创建完毕后执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span>&#123;<br>        <span class="hljs-comment">//给上下文context对象注入环境属性</span><br>        <span class="hljs-comment">//1.准备属性</span><br>        Map&lt;String,Object&gt;myMap <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        myMap.put(<span class="hljs-string">&quot;applicationName&quot;</span>,<span class="hljs-string">&quot;big-event&#x27;);</span><br><span class="hljs-string">        //2,获取一个属性资源管理对象</span><br><span class="hljs-string">        //获取的环境对象</span><br><span class="hljs-string">        ConfigurableEnvironment environment applicationContext.getEnvironment();</span><br><span class="hljs-string">        //属性资源管理对象</span><br><span class="hljs-string">        MutablePropertySources propertySources environment.getPropertySources();</span><br><span class="hljs-string">        /13.注册</span><br><span class="hljs-string">        propertySources.addLast(new MapPropertySource(name:&quot;</span>myMap<span class="hljs-string">&quot;,myMap));</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>2.在META-lNF&#x2F;spring.factories配置文件中配置自定义的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 接口全路径名称=自定义类的全路径名称<br>org.<span class="hljs-property">springframework</span>.<span class="hljs-property">context</span>.<span class="hljs-property">ApplicationContextInitializer</span>=com.<span class="hljs-property">itheima</span>.<span class="hljs-property">initializer</span>.<span class="hljs-property">MyApplicationContextInitializer</span><br></code></pre></td></tr></table></figure><p>3.在启动类中获取注入的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(App.class,args);<br>        String applicationName context.getEnvironment().getProperty(<span class="hljs-string">&quot;applicationName&quot;</span>);<br>        System.out.println(applicationName);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SVdH4">ApplicationListener</h3>监听容器发布的事件，允许程序员执行自己的代码，完成事件驱动开发，它可以监听容器初始化完成、初始化失败等事件。通常情况下可以使用监听器加载资源，开启定时任务等<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725186961167-080d83fd-0330-4a7c-84ea-a38141dd7585.png"></p><h4 id="gSkTu">使用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span>&#123;<br>        <span class="hljs-comment">//ApplicationEvent event对应的就是发布的事件，ApplicationReadyEvent,ApplicationFailedEvent</span><br>        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ApplicationReadyEvent)&#123;<br>            <span class="hljs-comment">//容器初始化成功</span><br>            System.out.println(<span class="hljs-string">&quot;MyListener..容器初始化成功...&quot;</span>)；<br>        &#125;<br>        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ApplicationFailedEvent)&#123;<br>            <span class="hljs-comment">//容器初始化失败</span><br>            System,out.println(<span class="hljs-string">&quot;MyListener.,.容器初始化失购，.&quot;</span>)；<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">org.<span class="hljs-property">springframework</span>.<span class="hljs-property">context</span>.<span class="hljs-property">ApplicationListener</span>=com.<span class="hljs-property">itheima</span>.<span class="hljs-property">listener</span>.<span class="hljs-property">MyListener</span><br></code></pre></td></tr></table></figure><h3 id="mZzZX">BeanFactory</h3>Bean容器的根接口，提供Bean对象的创建、配置、依赖注入等功能<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187658224-155ccf1f-25fa-4766-905f-7868647cb67b.png"></p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187658193-0d041178-b911-42de-8021-825c9fc07027.png"></p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187658117-71f19325-413e-4eb8-a6eb-94e98baf1127.png"></p><h4 id="I29Gy">使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(App.class,args);I<br>         <br>        <span class="hljs-comment">//AnnotationConfigServletWebServerApplicationContext</span><br>        System.out.println(context.getClass());<br>        <br>        <span class="hljs-type">App</span> <span class="hljs-variable">appBean</span> <span class="hljs-operator">=</span> context.getBean(App.class);<br>        System.out.println(appBean);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TT6Sv">BeanDefinition</h3>用于描述Bean,包括Bean的名称，Bean的属性，Bean的行为，实现的接口，添加的注解等等，Spring中，Bean在创建之前，都需要封装成对应的BeanDefinition,然后根据BeanDefinitioni进一步创建Bean对象。<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187675291-d0fff1ec-483d-4078-910a-3e61bc2ee9e7.png"></p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187675279-2a760d6e-8369-472a-9811-ca15d08538e0.png"></p><h4 id="VyRyu">使用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-comment">//Bean对应的信息回封装到ScannedGenericBeanDefinition</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">aa</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span><span class="hljs-string">&quot;我爱所有的美女&quot;</span>；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(App.class,args);I<br>         <br>         <span class="hljs-comment">//获取BeanDefinition对象</span><br>        ConfigurableListableBeanFactory beanFactory context.getBeanFactory();<br>        BeanDefinition userBdf beanFactory.getBeanDefinition(beanName:<span class="hljs-string">&quot;user&quot;</span>);<br>        BeanDefinition aaBdf beanFactory.getBeanDefinition(beanName:<span class="hljs-string">&quot;aa&quot;</span>);<br>        System.out.println(userBdf.getclass()); <span class="hljs-comment">//ScannedGenericBeanDefinition</span><br>        System.out.println(aaBdf.getclass()); <span class="hljs-comment">//ConfigurationClassBeanDefinition</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xDbtR">BeanFactoryPostProcessor</h3>Bean工厂后置处理器，当BeanFactory.准备好了后(Bean初始化之前)，会调用该接口的postProcessBeanFactory)方法，经常用于新增BeanDefinition。<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187689406-6ad8c83e-eb9c-416a-8566-d19cde17fb60.png"></p><h4 id="yO5pX">使用方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class Teacher &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span>&#123;<br>    <span class="hljs-comment">//当beanFactory被实例化好后(bean创建之前)，回调这个函数，注册一些BeanDefinition</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span><span class="hljs-keyword">throws</span> BeansException&#123;<br>        <span class="hljs-comment">//注册一个Teacher的BeanDefinition</span><br>        GenericBeanDefinition gbdf <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericBeanDefinition</span>();<br>        gbdf.setBeanClass(Teacher.class);<br>        <span class="hljs-comment">//向下强转</span><br>        DefaultListableBeanFactory <span class="hljs-title function_">dbf</span> <span class="hljs-params">(DefaultListableBeanFactory)</span>beanFactory;<br>        dbf.registerBeanDefinition(beanName:<span class="hljs-string">&quot;teacher&quot;</span>,gbdf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(App.class,args);I<br>         <br>         System.out.println(context.getBean(name:<span class="hljs-string">&quot;teacher&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cy2AC">Aware</h3>感知接口，Spring提供的一种机制，通过实现该接口，重写方法，可以感知Spring应用程序执行过程中的一些变化。Spring会判断当前的Bean有没有实现Aware接口，如果实现了，会在特定的时机回调接口对应的方法。<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187697449-c4f334b5-f514-4465-83fd-84217bbd6e41.png"></p><h4 id="X75qP">使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span>,BeanclassLoaderAware,BeanFactoryAware&#123;<br>    <span class="hljs-comment">//BeanclassLoader的回调方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanclassLoader</span><span class="hljs-params">(CLassLoader classLoader)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Student...setBeanclassLoader...&quot;</span>+classLoader);<br>    &#125;<br>    <span class="hljs-comment">//BeanFactoryAware的回调方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span><span class="hljs-keyword">throws</span> BeansException<br>    System.out.println(<span class="hljs-string">&quot;Student...setBeanFactory...&quot;</span>+beanFactory);<br>&#125;<br><span class="hljs-comment">//BeanNameAware的回调方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Student...setBeanName...&quot;</span>+name);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="GtBIE">InitializingBean/DisposableBean</h3><ul><li>初始化接口，当Bean被实例化好后，会回调里面的函数，经常用于做一些加载资源的工作</li><li>销毁接口，当Bean被销毁之前，会回调里面的函数，经常用于做一些释放资源的工作</li></ul><h4 id="I9Yaf">使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>,DisposableBean&#123;<br><br>    <span class="hljs-comment">//PostConstructor,PreDestroy,提供初始化方法和销毁方法的注解</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal...PostConstruct..initMethod&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal...PreDestroy..destroyMethod&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//手动实现初始化方法和销毁方法</span><br>    <span class="hljs-comment">//销毁方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal...destroy...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//初始化方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal...afterPropertiesSet...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="foAYo">BeanPostProcessor</h3>Bean的后置处理器，当Bean对象初始化之前以及初始化之后，会回调该接口对应的方法<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187713651-2076b85c-a651-412a-b855-419ecaaedae9.png"></p><h4 id="me62Z">使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span>&#123;<br>    <span class="hljs-comment">//初始化之前调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean,String beanName)</span><span class="hljs-keyword">throws</span> BeansException&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyBeanPostProcessor...postProcessBeforeInitialization...&quot;</span>+beanName);<br>        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessBeforeInitialization(bean,beanName);<br>    &#125;<br><br>    <span class="hljs-comment">//初始化之后调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(object bean,String beanName)</span><span class="hljs-keyword">throws</span> BeansException&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyBeanPostProcessor...postProcessAfterInitialization...&quot;</span>+beanName);<br>        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessAfterInitialization(bean,beanName);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="V2ZQc">面试题</h2><h3 id="qQhDn">SpringBoot启动流程</h3><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187727190-4965d62d-9804-4e33-bfd7-f35a048e2e17-172856656426912.png"></p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725187726518-ef7d09e4-471f-4567-a1a5-fd8fa2b35f10.png"></p><p>总：SpringBoot启动，其本质就是<strong>加载各种配置信息，然后初始化Ioc容器并返回</strong></p><p>分：在其启动的过程中会做这么几个事情<br>    首先，当我们在启动类执行SpringApplication.run这行代码的时候，在它的方法内部其实会做两个事情<br>        1.<strong>创建SpringApplication对象；</strong><br>        2.<strong>执行run方法。</strong><br>    其次，在创建SpringApplication对象的时候，在它的构造方法内部主要做3个事情。<br>        1.<strong>确认web应用类型</strong>，一般情况下是Servlet类型，这种类型的应用，将来会自动启动一个tomcat<br>        2.从spring.factories配置文件中，<strong>加载默认的ApplicationContextInitializer和ApplicationListener</strong><br>        3.<strong>记录当前应用的主启动类</strong>，将来做包扫描使用<br>    最后，对象创建好了以后，再调用该对象的run方法，在run方法的内部主要做4个事情<br>        1.<strong>准备Environment对象</strong>，它里面会封装一些当前应用运行环境的参数，比如环境变量等等<br>        2.<strong>实例化容器</strong>，这里仅仅是创建ApplicationContext对象<br>        3.容器创建好了以后，会<strong>为容器做一些准备工作</strong>，比如为容器设置Environment、BeanFactoryPostProcessor后置处理器，并且加载主类对应的Definition<br>        4.<strong>刷新容器</strong>，就是我们常说的referesh,在这里会真正的创建Bean实例</p><p>总：总结一下我刚说的，其实SpringBoot启动的时候核心就两步，创建SpringApplication对象以及run方法的调用，在run方法中会真正的实例化容器，并创建容器中需要的Bean实例，最终返回。</p><h3 id="M48k0">IOC容器初始化流程</h3><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725239887791-018247f7-97ee-4025-8ce2-2762678ef040.png"></p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725269735691-83b7cae9-18f2-4afa-8c58-cc6ff1f07ab4.png"></p><p><strong>总：</strong>IOC容器的初始化，核心工作是在<strong>AbstractApplicationContext..refresh</strong>,方法中完成的</p><p><strong>分：</strong>在refresh方法中主要做了这么几件事</p><p>1.<strong>准备BeanFactory</strong>,在这一块需要给BeanFacory设置很多属性，比如类加载器、Environment等</p><p>2.<strong>执行BeanFactory后置处理器</strong>，这一阶段会扫描要放入到容器中的Bean信息，得到对应的BeanDefinition(注意，这里只扫描，不创建)》</p><p>3.是<strong>注册BeanPostProcesor</strong>,,我们自定义的BeanPostProcessor就是在这一个阶段被加载的，将来Bean对象实例化好后需要用到</p><p>4.<strong>启动tomcat</strong></p><p>5.<strong>实例化容器中实例化非懒加载的单例Bean</strong>,这里需要说的是，多例Bean和懒加载的Bean不会在这个阶段实例化，将来用到的时候再创建</p><p>6.当容器初始化完毕后，再做一些<strong>扫尾工作</strong>，比如清除缓存等</p><p><strong>总：</strong>简单总结一下，在IOC容器初始化的的过程中，首先得**<u>准备并执行BeanFactory后置处理器</u><strong>，其次得</strong><u>注册Bean后置处理器</u><strong>，并</strong><u>启动tomcat,</u><strong>.最后需要</strong><u>借助于BeanFactory完成Bean的实例化</u>**</p><h3 id="JVQoF">Bean的生命周期</h3><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725270255880-7fee4917-9ac3-4d36-961a-5e0b35fa2121.png"></p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725271239323-8966145d-d264-4f63-bebe-294c2b713e6d.png"></p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725271319052-292cbd71-9a06-4d32-a0e8-a3d38d256230.png"></p><p><strong>总：</strong>Bea的生命周期总的来说有4个阶段，分别有<u>创建对象，</u><u><font style="background-color:#FBDE28;">初始化对象</font></u><u>，使用对象以及销毁对象</u>，而且这些工作大部分是交给<strong>Bean工厂的doCreateBean方法</strong>完成的</p><p><strong>分：</strong></p><p>首先，在创建对象阶段，先调用构造方法<strong>实例化对象</strong>，对象有了后会<strong>填充该对象的内容</strong>，其实就是处理<strong>依赖注入</strong></p><p>其次，对象创建完毕后，需要做一些<strong>初始化的操作</strong>，在这里涉及到几个扩展点。</p><p>1.执行<strong>Aware感知接口</strong>的回调方法</p><p>2.执行Bean后置处理器的<strong>postProcessBeforelnitialization方法</strong></p><p>3.执行<strong>InitializingBean接口的回调</strong>，在这一步如果Bean中有标注了@PostConstructi注解的方法，会先执行它</p><p>4.执行Bean后置处理器的<strong>postProcessAfterlnitialization</strong></p><p>把这些扩展点都执行完，Bean的初始化就完成了</p><p>接下来，在使用阶段就是程序员从容器中获取该Bean使用即可</p><p>最后，在容器销毁之前，会先<strong>销毁对象</strong>，此时会执行Disposable Bean接口的回调，这一步如果Bean中有标注了@PreDestroy接口的函数，会先执行它</p><p><strong>总：</strong>简单总结一下，Bea的生命周期共包含四个阶段，其中初始化对象和销毁对象我们程序员可以通过一些扩展点执行自己的代码</p><h3 id="VU3hV">Bean循环依赖</h3>![](Java面试——SpringBoot篇/1725341720272-9eaf5725-4656-46d3-a9da-c996fd742fa1.png)<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725342427033-0e236bc9-c218-4b1a-b7b8-22d32e8b4dc7.png"></p><p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/1725343132168-ec215d6c-26c2-4ee9-a440-d4f960184fea.png"></p><p><strong>总：</strong>Bean的循环依赖指的是A依赖B,B又依赖A这样的依赖闭环问题，在Springl中，通过<strong>三个对象缓存区</strong>来解决循环依赖问题，这三个缓存区被定义到了<strong>DefaultSingletonBeanRegistry</strong>中，分别是<strong>singletonObjects</strong>用来存储创建完毕的Bean,<strong>earlySingletonObjects</strong>用来存储未完成依赖注入的Bean,还有<strong>SingletonFactories</strong>用来存储创建Bean的ObjectFactory。假如说现在A依赖B,B依赖A,整个Bean的创建过程是这样的</p><p><strong>分：</strong></p><p>首先，调用A的构造方法<strong>实例化A</strong>,当前的A还没有处理依赖注入，暂且把它称为半成品，此时会把<strong>半成品A封装到一个ObjectFactory中</strong>，并存储到springFactories缓存区</p><p>接下来，要<strong>处理A的依赖注入</strong>了，由于此时还没有B,所以得先<strong>实例化一个B</strong>,同样的，半成品<strong>B也会被封装到ObjectFactory</strong>中并存储到springFactory缓存区</p><p>紧接着，要<strong>处理B的依赖注入</strong>了，此时会找到springFactories中A对应的ObjecFactory,调用它的<strong>getObject方法</strong>得到刚才实例化的半成品A(如果需要代理对象，则会自动创建代理对象，将来得到的就是代理对象)，把得到的<strong>半成品A注入给B</strong>,并同时会把<strong>半成品A存入到earlySingletonObjects</strong>中，将来如果还有其他的类循环依赖了A,就可以直接从earlySingletonObjects中找到它了，那么此时springFactories中<strong>创建A的ObjectFactory也可以删除</strong>了。</p><p>至此，B的依赖注入处理完了后，B就创建完毕了，就可以把<strong>B的对象存入到singletonObjects</strong>中了，并同时<strong>删除掉springFactories中创建B的ObjectFactory</strong></p><p>B创建完毕后，就可以<strong>继续处理A的依赖注入</strong>了，把B注入给A,此时A也创建完毕了，就可以把<strong>A的对象存储到singletonObjects</strong>中，并同时<strong>删除掉earlySingletonObjects中的半成品A</strong></p><p>截此为止，A和B对象全部<strong>创建完毕</strong>，并存储到了singletonObjects中，将来通过容器获取对象，都是<strong>从singletonObejcts中获取</strong>。</p><p><strong>总：</strong>总结起来还是一句话，借助于DefaultSingletonBeanRegistry的三个缓存区可以解决循环依赖问题</p><h3 id="SN4VA">SpringMvc执行流程</h3>![](Java面试——SpringBoot篇/1725344403683-f6f596c2-623a-447d-b615-60aeeda5e1d9.png)<p><strong>总：</strong>使用了SpringMvc后，所有的请求都需要经过DispatcherServlet前端控制器，该类中提供了一个doDispatch方法，有关请求处理和结果响应的所有流程都在该方法中完成</p><p><strong>分：</strong></p><p>首先，借助于HandlerMapping处理器映射器得到处理器执行链，里面封装了HandlerMethod代表目标Controller的方法，同时还通过一个集合记录了要执行的拦截器。</p><p>接下来，会根据HandlerMethod获取对应的HandlerAdapter处理器适配器，里面封装了参数解析器以及结果处理器。</p><p>然后，执行拦截器的preHandle方法。</p><p>接下来是核心，通过HandlerAdapter处理器适配器执行目标Controller的方法，在这个过程中会通过参数解析器和结果处理器分别解析浏览器提交的数据以及处理Controller方法返回的结果。</p><p>然后，执行拦截器的postHandle方法。</p><p>最后处理响应，在这个过程中如果有异常抛出，会执行异常的逻辑，这里还会执行全局异常处理器的逻辑，并通过视图解析器ViewResolver解析视图，再渲染视图，最后再执行拦截器的afterCompletion。</p>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>JAVA</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多数元素</title>
    <link href="/2024/10/10/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <url>/2024/10/10/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>给定一个大小为 <code>n</code>_ _的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,2,3]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,2,1,1,1,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><a name="wbMao"></a></p><h2 id="解法1：HashMap"><a href="#解法1：HashMap" class="headerlink" title="解法1：HashMap"></a>解法1：HashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer,Integer&gt; counts = countNums(nums);<br><br>        Map.Entry&lt;Integer,Integer&gt; major = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">//Map.entrySet() 得到Map中所有键值对的Set</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : counts.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span>(major == <span class="hljs-literal">null</span> || entry.getValue() &gt; major.getValue()) &#123;<br>                major = entry;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> major.getKey();<br>    &#125;<br><br>    <span class="hljs-comment">//countNums方法将数组中的元素及其出现的次数进行统计</span><br>    <span class="hljs-keyword">public</span> Map&lt;Integer,Integer&gt; <span class="hljs-title function_">countNums</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><br>        Map&lt;Integer, Integer&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer,Integer&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">//Map.containsKey(key) 表示Map中是否包含该key</span><br>            <span class="hljs-keyword">if</span>(hashmap.containsKey(arr[i])) &#123;<br>                <span class="hljs-comment">//map中更新某个key对应的value，直接重新put就行</span><br>                hashmap.put(arr[i], hashmap.get(arr[i])+<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                hashmap.put(arr[i], <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hashmap;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="VjNhS"></a></p><h2 id="解法2：排序"><a href="#解法2：排序" class="headerlink" title="解法2：排序"></a>解法2：排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//出现次数大于n/2，直接排序完去索引为n/2处的值</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并有序数组</title>
    <link href="/2024/10/10/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2024/10/10/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code>_ <em>和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。<br>请你 <strong>合并</strong> <code>nums2</code></em> _到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。<br><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。<br><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,0,0,0]</span>, m = 3, nums2 = <span class="hljs-comment">[2,5,6]</span>, n = 3<br>输出：<span class="hljs-comment">[1,2,2,3,5,6]</span><br>解释：需要合并 <span class="hljs-comment">[1,2,3]</span> 和 <span class="hljs-comment">[2,5,6]</span> 。<br>合并结果是 <span class="hljs-comment">[1,2,2,3,5,6]</span> ，其中斜体加粗标注的为 nums1 中的元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1]</span>, m = 1, nums2 = <span class="hljs-comment">[]</span>, n = 0<br>输出：<span class="hljs-comment">[1]</span><br>解释：需要合并 <span class="hljs-comment">[1]</span> 和 <span class="hljs-comment">[]</span> 。<br>合并结果是 <span class="hljs-comment">[1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[0]</span>, m = 0, nums2 = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br>解释：需要合并的数组是 <span class="hljs-comment">[]</span> 和 <span class="hljs-comment">[1]</span> 。<br>合并结果是 <span class="hljs-comment">[1]</span> 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。<br></code></pre></td></tr></table></figure><p><a name="D2spV"></a></p><h2 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123; <br>        <span class="hljs-type">int</span>[] nums1_copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        System.arraycopy(nums1,<span class="hljs-number">0</span>,nums1_copy,<span class="hljs-number">0</span>,m);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (p != m &amp;&amp; q != n) &#123; <br>            nums1[cur++] = nums1_copy[p] &gt; nums2[q] ? nums2[q++] : nums1_copy[p++];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(p &lt; m)<br>            System.arraycopy(nums1_copy,p,nums1,p+q,m+n-p-q);<br>        <span class="hljs-keyword">if</span>(q &lt; n)<br>            System.arraycopy(nums2,q,nums1,p+q,m+n-p-q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="WHHsV"></a></p><h2 id="解法2：合并排序"><a href="#解法2：合并排序" class="headerlink" title="解法2：合并排序"></a>解法2：合并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != n; ++i) &#123;<br>            nums1[m + i] = nums2[i];<br>        &#125;<br>        Arrays.sort(nums1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证回文串</title>
    <link href="/2024/10/10/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <url>/2024/10/10/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong>。字母和数字都属于字母数字字符。</p><p>给你一个字符串<code>s</code>，如果它是<strong>回文串</strong> ，返回 <code>true</code>；否则，返回<code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: s = &quot;A man, a plan, a canal: Panama&quot;<br>输出：true<br>解释：&quot;amanaplanacanalpanama&quot; 是回文串。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：s = &quot;race a car&quot;<br>输出：false<br>解释：&quot;raceacar&quot; 不是回文串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：s = &quot; &quot;<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 &quot;&quot; 。<br>由于空字符串正着反着读都一样，所以是回文串。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> removeNonAlphanumeric(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>, q = str.length()-<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(p&lt;q) &#123;<br>            <span class="hljs-keyword">if</span>(str.charAt(p) == str.charAt(q)) &#123;<br>                p++;<br>                q--;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// public String replaceAll(String regex, String replacement)</span><br>    <span class="hljs-comment">// 这个方法接受两个参数：</span><br>    <span class="hljs-comment">// regex：一个正则表达式，用于指定要被替换的字符序列的模式。</span><br>    <span class="hljs-comment">// replacement：用于替换匹配到的字符序列的字符串。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">removeNonAlphanumeric</span><span class="hljs-params">(String str)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> str.toLowerCase().replaceAll(<span class="hljs-string">&quot;[^a-z0-9]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> newStr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除有序数组中的重复项 II</title>
    <link href="/2024/10/10/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20II/"/>
    <url>/2024/10/10/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20II/</url>
    
    <content type="html"><![CDATA[<p>给你一个有序数组<code>nums</code> ，请你<strong>原地</strong> 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在[<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：nums = [1,1,1,2,2,3]<br>输出：5, nums = [1,1,2,2,3]<br>解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：nums = [0,0,1,1,1,1,2,3,3]<br>输出：7, nums = [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums.length;<br>        &#125;<br><br>        <span class="hljs-comment">//slow表示处理完成的数组长度，fast表示扫描过的数组长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, slow = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">while</span>(fast &lt; nums.length) &#123;<br>            <span class="hljs-comment">//最多出现两次，所以将slow-2处的数与fast处的数进行比较</span><br>            <span class="hljs-keyword">if</span>(nums[slow-<span class="hljs-number">2</span>] != nums[fast]) &#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2024/10/10/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/10/10/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>给定一个整数数组ums和一个整数目标值target,请你在该数组中钱出和为目标值target的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">示例 1：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br></code></pre></td></tr></table></figure><p><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">示例 2：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br></code></pre></td></tr></table></figure><p><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">示例 3：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：nums = [3,3], target = 6<br>输出：[0,1]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历数组，到map中查找nums[i]对应的target-nums[i]</span><br><span class="hljs-comment">//查不到，则将(target-nums[i], i)存入map</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; hashtable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;<br>            &#125;<br>            hashtable.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效字母异位词</title>
    <link href="/2024/10/08/%E6%9C%89%E6%95%88%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2024/10/08/%E6%9C%89%E6%95%88%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;<br>输出: true<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: s = &quot;rat&quot;, t = &quot;car&quot;<br>输出: false<br></code></pre></td></tr></table></figure><h2 id="Jy0cv">解法1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将两个字符串转为字符数组后，排序并进行比较</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">char</span>[] str1 = s.toCharArray();<br>        <span class="hljs-type">char</span>[] str2 = t.toCharArray();<br>        Arrays.sort(str1);<br>        Arrays.sort(str2);<br>        <span class="hljs-keyword">return</span> Arrays.equals(str1, str2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A3zSx">解法2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用一个1*26的数组代表26个字母</span><br><span class="hljs-comment">//遍历s，对应的字母++</span><br><span class="hljs-comment">//再遍历t，对应字母--</span><br><span class="hljs-comment">//若出现小于0的结果，则代表出现了s中没有的字母</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            table[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            table[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span> (table[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>努力成为牛马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青岛</title>
    <link href="/2024/06/03/%E9%9D%92%E5%B2%9B/"/>
    <url>/2024/06/03/%E9%9D%92%E5%B2%9B/</url>
    
    <content type="html"><![CDATA[<p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010233807807.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010233937485.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234000952.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234017569.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234033080.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234057809.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234128135.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234140382.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234149132.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234221067.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234240326.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234251493.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234320938.png"></p><br><p><img src="/2024/06/03/%E9%9D%92%E5%B2%9B/image-20241010234336487.png"></p>]]></content>
    
    
    <categories>
      
      <category>生活如此多娇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游</tag>
      
      <tag>美好</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
