

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/bitbug_favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="柴勇玛喜达">
  <meta name="keywords" content="">
  
    <meta name="description" content="基本数据类型与包装类   基本数据类型与引用数据类型区别   存储方式：基本数据类型直接存储值，而引用数据类型存储的是对象的引用（内存地址）  内存分配：基本数据类型在栈上分配内存，引用数据类型在堆上分配内存（_具体内容存放在堆中，栈中存放的是其具体内容所在内存的地址_）。栈上的分配速度较快，但是内存空间较小，而堆上的分配速度较慢，但可以分配更大的内存空间  默认值：基本数据类型会有默认值，例如i">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试——基础篇">
<meta property="og:url" content="https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/index.html">
<meta property="og:site_name" content="柴勇玛喜达のBLOG">
<meta property="og:description" content="基本数据类型与包装类   基本数据类型与引用数据类型区别   存储方式：基本数据类型直接存储值，而引用数据类型存储的是对象的引用（内存地址）  内存分配：基本数据类型在栈上分配内存，引用数据类型在堆上分配内存（_具体内容存放在堆中，栈中存放的是其具体内容所在内存的地址_）。栈上的分配速度较快，但是内存空间较小，而堆上的分配速度较慢，但可以分配更大的内存空间  默认值：基本数据类型会有默认值，例如i">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.png">
<meta property="og:image" content="https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/String%E7%9B%B8%E5%85%B3.png">
<meta property="og:image" content="https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/String%E5%B0%8F%E7%BB%93.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/27509659/1715667356881-b30de396-12ef-425f-ab02-37e2eb705816.png">
<meta property="og:image" content="https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/Exception%E5%92%8CError.png">
<meta property="og:image" content="https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/tcp4%E5%B1%82%E6%A8%A1%E5%9E%8B.png">
<meta property="article:published_time" content="2024-10-10T09:22:57.614Z">
<meta property="article:modified_time" content="2024-10-10T16:40:55.784Z">
<meta property="article:author" content="柴勇玛喜达">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java面试——基础篇 - 柴勇玛喜达のBLOG</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/shubiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css">
<link rel="stylesheet" href="/css/cloudedGlass.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.guxiang.lol","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>柴勇玛喜达</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Java面试——基础篇</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-10-10 17:22" pubdate>
          2024年10月10日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          75 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java面试——基础篇</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2024-10-11T00:40:55+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="uc3Ar">基本数据类型与包装类</h2>

<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="基本数据类型"></p>
<h3 id="gYvgU"><font style="color:rgb(0, 0, 0);">基本数据类型与引用数据类型区别</font></h3>

<ul>
<li><p>存储方式：基本数据类型直接<strong>存储值</strong>，而引用数据类型存储的是对象的引用（<strong>内存地址</strong>）</p>
</li>
<li><p>内存分配：基本数据类型在<strong>栈</strong>上分配内存，引用数据类型在<strong>堆</strong>上分配内存（_具体内容存放在堆中，栈中存放的是其具体内容所在内存的地址_）。栈上的分配速度较快，但是内存空间较小，而堆上的分配速度较慢，但可以分配更大的内存空间</p>
</li>
<li><p>默认值：基本数据类型会<strong>有默认值</strong>，例如int类型的默认值是0，boolean类型的默认值是false。而引用数据类型的默认值<strong>是null</strong>，表示没有引用指向任何对象</p>
</li>
<li><p>参数传递：基本数据类型作为方法的参数传递时，<strong>传递的是值的副本</strong>，不会修改原始值。而引用数据类型作为方法的参数传递时，传递的是对象的引用，<strong>可以修改对象的属性或状态</strong></p>
</li>
<li><p>比较操作：基本数据类型使用进行比较时，比较的是<strong>值是否相等</strong>。而引用数据类型使用&#x3D;&#x3D;进行比较时，比较的是引用是否指向同一个对象（<strong>地址</strong>），如果要比较对象的内容是否相同，需要使用<strong>equals()方法</strong></p>
</li>
</ul>
<p>注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong>基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是<strong>局部变量</strong>，那么它们会存放在<strong>栈中</strong>；如果它们是<strong>成员变量</strong>，那么它们会存放在<strong>堆中</strong>。</p>
<h3 id="hpaQX">包装类型的缓存机制</h3>

<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <strong>Float</strong> ,<strong>Double</strong>并没有实现缓存机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于Integer类型的缓存机制，且33在-128-127之间，所以他们比较的相当于是常量的值</span><br><span class="hljs-comment">//而Float，Double没有缓存机制，所以他们相当于比较的是两个对象的地址</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br>System.out.println(i1 == i2);<span class="hljs-comment">// 输出 true</span><br><br><span class="hljs-type">Float</span> <span class="hljs-variable">i11</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br><span class="hljs-type">Float</span> <span class="hljs-variable">i22</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>System.out.println(i11 == i22);<span class="hljs-comment">// 输出 false</span><br><br><span class="hljs-type">Double</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br><span class="hljs-type">Double</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>System.out.println(i3 == i4);<span class="hljs-comment">// 输出 false</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。</span><br><span class="hljs-comment">//因此，i1 直接使用的是缓存中的对象。而Integer i2 = new Integer(40) 会直接创建新的对象。</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">40</span>);<br>System.out.println(i1==i2);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</strong></p>
<h2 id="bQZbZ">浮点数计算会丢失精度？</h2>
因为Java中不是所有小数都能用二进制表示，浮点数只是近似值，不是精确值。Java中提供BigDecimal进行精确运算。

<p>小数二进制表示方法：例如0.625，将小数不断乘2，取整数部分</p>
<p>0.625*2 &#x3D; 1.25——————1</p>
<p>0.25*2   &#x3D; 0.5  ——————0</p>
<p>0.5*2     &#x3D; 1     ——————1</p>
<p>所以0.625二进制表示为0.101</p>
<p>但例如0.2则无法表示</p>
<p>BigDecimal可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过BigDecimal来做的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a.subtract(c);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b.subtract(c);<br><br>System.out.println(x); <span class="hljs-comment">/* 0.2 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.20 */</span><br><span class="hljs-comment">// 比较内容，不是比较值</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* false */</span><br><span class="hljs-comment">// 比较值相等用相等compareTo，相等返回0</span><br>System.out.println(<span class="hljs-number">0</span> == x.compareTo(y)); <span class="hljs-comment">/* true */</span><br></code></pre></td></tr></table></figure>

<h2 id="nNTkk">变量相关</h2>
<h3 id="JB0Ih">成员变量与局部变量</h3>

<ul>
<li><p><strong>语法形式</strong>：从语法形式上看，成员变量是<strong>属于类</strong>的，而局部变量是在<strong>代码块或方法中</strong>定义的变量或是方法的参数；成员变量可以被 <strong>public</strong>,<strong>private</strong>,<strong>static</strong> 等修饰符所修饰，而局部变量<strong>不能被访问控制修饰符及 static所修饰</strong>；但是，成员变量和局部变量<strong>都能被 final所修饰</strong>。</p>
</li>
<li><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是<strong>属于类的</strong>，如果没有使用 <code>static</code> 修饰，这个成员变量是<strong>属于实例的</strong>。而_对象存在于堆内存，局部变量则存在于栈内存。_</p>
</li>
<li><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它<strong>随着对象的创建而存在</strong>，而局部变量_随着方法的调用而自动生成，随着方法的调用结束而消亡_。</p>
</li>
<li><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会<strong>自动以类型的默认值而赋值</strong>（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局<strong>部变量则不会自动赋值</strong>。</p>
</li>
</ul>
<h3 id="mYOVl">静态变量</h3>

<p>静态变量也就是被 <code>static</code> 关键字修饰的变量。它可以<strong>被类的所有实例共享</strong>，无论一个类创建了多少个对象，它们都<strong>共享同一份静态变量</strong>。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p>
<p>静态变量是<strong>通过类名来访问</strong>的，例如<code>StaticVariableExample.staticVar</code>（如果被 <code>private</code>关键字修饰就无法这样访问了）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticVariableExample</span> &#123;<br>    <span class="hljs-comment">// 静态变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>通常情况下，静态变量会<strong>被</strong>final<strong>关键字修饰成为常量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantVariableExample</span> &#123;<br>    <span class="hljs-comment">// 常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">constantVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="nwil5">静态方法为什么不能调用非静态成员？</h2>

<ul>
<li><p>静态方法是<strong>属于类的</strong>，在<strong>类加载的时候就会分配内存</strong>，可以通过类名直接访问。而非静态成员<strong>属于实例对象</strong>，只有在对象<strong>实例化之后才存在</strong>，需要通过类的实例对象去访问。</p>
</li>
<li><p>_在类的非静态成员不存在的时候静态方法就已经存在了_，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-comment">// 定义一个字符型常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">LETTER_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>    <span class="hljs-comment">// 定义一个字符串常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">GREETING_MESSAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 输出字符型常量的值</span><br>        System.out.println(<span class="hljs-string">&quot;字符型常量的值为：&quot;</span> + LETTER_A);<br><br>        <span class="hljs-comment">// 输出字符串常量的值</span><br>        System.out.println(<span class="hljs-string">&quot;字符串常量的值为：&quot;</span> + GREETING_MESSAGE);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="c2WL2">静态方法和实例方法有何不同？</h3>
<h4 id="v1GQp">1、调用方式</h4>

<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p>
<p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staicMethod</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 调用实例方法</span><br>        person.method();<br>        <span class="hljs-comment">// 调用静态方法</span><br>        Person.staicMethod()<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="r4XcA">2、访问类成员是否存在限制</h4>
静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。

<h2 id="UDqVC">重载与重写</h2>

<h3 id="H6pnJ">重载</h3>

<p>发生在<strong>同一个类中（或者父类和子类之间）</strong>，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同（<strong>仅要求方法名相同</strong>）。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<h3 id="yviDa">重写</h3>

<p>重写发生<strong>在运行期</strong>，是<strong>子类对父类的允许访问的方法</strong>的实现过程进行<strong>重新编写</strong>。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p><strong>方法的重写要遵循“两同两小一大”</strong>：</p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的_返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。_</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级英雄&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超人&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Hero <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperSuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperMan</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级超级英雄&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SuperMan <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMan</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="ZpXrF">面向对象三大特征</h2>
<h3 id="VR77A">封装</h3>

<p> 封装是指把_<strong>一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息</strong><em>。但是可以</em><strong>提供一些可以被外界访问的方法来操作属性</strong>_。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//id属性私有化</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//name属性私有化</span><br><br>    <span class="hljs-comment">//获取id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-comment">//设置id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-comment">//获取name的方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-comment">//设置name的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="ci6hw">继承</h3>

<p> 不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是<strong>使用已存在的类的定义作为基础建立新类的技术</strong>，新类的定义_可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类_。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问。</li>
<li>子类<strong>可以拥有自己属性和方法</strong>，即子类可以对父类进行扩展。</li>
<li>子类<strong>可以用自己的方式实现父类的方法</strong>。（以后介绍）。</li>
</ol>
<h3 id="m1PMP">多态</h3>
多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

<p><strong>多态的特点:</strong></p>
<ul>
<li><strong>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系</strong>；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li>
</ul>
<h2 id="Pgghw">接口和抽象类的区别</h2>
<h3 id="BDZ8B">共同点</h3>

<ul>
<li><strong>实例化</strong>：接口和抽象类都<strong>不能直接实例化</strong>，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。</li>
<li><strong>抽象方法</strong>：接口和抽象类都<strong>可以包含抽象方法</strong>。<em>抽象方法没有方法体，必须在子类或实现类中实现。</em></li>
</ul>
<h3 id="tYoOr">区别</h3>

<ul>
<li><p><strong>设计目的</strong>：接口主要用于<strong>对类的行为进行约束</strong>，你实现了某个接口就具有了对应的行为。抽象类主要<strong>用于代码复用</strong>，强调的是所属关系。</p>
</li>
<li><p><strong>继承和实现</strong>：一个类<strong>只能继承一个类（包括抽象类）</strong>，因为 Java 不支持多继承。但一个类可以<strong>实现多个接口</strong>，一个接口也可以继承多个其他接口。</p>
</li>
<li><p><strong>成员变量</strong>：接口中的<strong>成员变量只能是 public static final 类型的</strong>，不能被修改且<strong>必须有初始值</strong>。抽象类的成员变量<strong>可以有任何修饰符</strong>（<code>private</code>, <code>protected</code>, <code>public</code>），可以在子类中被重新定义或赋值。</p>
</li>
<li><p><strong>方法</strong>： </p>
<ol>
<li><p>Java 8 之前，接口中的方法<strong>默认是 public abstract <strong>，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 <strong>default（默认） 方法和 static（静态）方法</strong>。Java 8 引入的static方法无法在实现类中被覆盖，只能通过接口名直接调用，类似于类中的静态方法。static方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。自 Java 9 起，接口</strong>可以包含 private 方法</strong>。private方法可以用于在接口内部共享代码，不对外暴露。</p>
</li>
<li><p>抽象类<strong>可以包含抽象方法和非抽象方法</strong>。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</p>
</li>
</ol>
</li>
</ul>
<h2 id="jTwOr">深拷贝和浅拷贝</h2>

<ul>
<li><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
</li>
<li><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
</li>
</ul>
<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.png" srcset="/img/loading.gif" lazyload alt="深拷贝与浅拷贝"></p>
<h2 id="LnHfA">hashCode()和equals()</h2>
<h3 id="FnNW4">equals()</h3>

<p><code>equals()</code> 不能用于判断基本数据类型的变量，<strong>只能用来判断两个对象是否相等</strong>。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此<strong>所有的类都有equals()方法。</strong></p>
<p><strong>String</strong>中的<strong>equals</strong>方法是被重写过的<strong>，比较的是 String 字符串的值是否相等。 Object</strong>的<strong>equals方法是比较的对象的内存地址。</strong></p>
<h3 id="UVHmC">hashCode()</h3>

<p>hashCode()的作用是<strong>获取哈希码</strong>（int整数），也称为散列码。这个哈希码的作用是<strong>确定该对象在哈希表中的索引位置。</strong></p>
<p>其实，hashCode() 和 equals()<strong>都是用于比较两个对象是否相等</strong>。</p>
<p>总结下来就是：</p>
<ul>
<li><p>如果两个对象的hashCode值相等，那这两个对象不一定相等（哈希碰撞）。</p>
</li>
<li><p>如果两个对象的hashCode值相等并且equals()方法也返回true，我们才认为这两个对象相等。</p>
</li>
<li><p>如果两个对象的hashCode值不相等，我们就可以直接认为这两个对象不相等。</p>
</li>
</ul>
<h2 id="UGgnZ">String、StringBuffer、StringBuilder 的区别</h2>

<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/String%E7%9B%B8%E5%85%B3.png" srcset="/img/loading.gif" lazyload alt="String相关"></p>
<h3 id="esGci">可变性</h3>

<p><code>String</code> <strong>是不可变的</strong>（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<h3 id="jcgb3">线程安全</h3>

<p><code>String</code> 中的对象是不可变的，也就<strong>可以理解为常量，线程安全</strong>。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全的</strong></p>
<h3 id="L5JlZ">性能</h3>

<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt="String常用方法"></p>
<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/String%E5%B0%8F%E7%BB%93.png" srcset="/img/loading.gif" lazyload alt="String小结"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/27509659/1715667356881-b30de396-12ef-425f-ab02-37e2eb705816.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="ZWdar">对于三使用的总结：</h3>

<ul>
<li><p>操作少量的数据: 适用String</p>
</li>
<li><p>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</p>
</li>
<li><p>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p>
</li>
</ul>
<h3 id="FrKXG">String为什么不可变？</h3>

<ul>
<li><p>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</p>
</li>
<li><p><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p>
</li>
</ul>
<h3 id="TLC70">String s1 = new String("abc");这句话一个创建几个对象？</h3>

<p><strong>字符串常量池</strong>是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是<strong>为了避免字符串的重复创建</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><br><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p>
<p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<h3 id="BLnpB">String.intern()</h3>

<p><code>String.intern()</code> 是一个 native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p>
<ul>
<li><p>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</p>
</li>
<li><p>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”Java“</span><br><span class="hljs-comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br><span class="hljs-comment">// 会在堆中在单独创建一个字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s3.intern();<br><span class="hljs-comment">// s1 和 s2 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// s3 和 s4 指向的是堆中不同的对象</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// s1 和 s4 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s4); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于编译器的优化，&quot;str&quot; + &quot;ing&quot;会被优化为&quot;string&quot;</span><br><span class="hljs-comment">//而str1 + str2为引用类型，引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<span class="hljs-comment">//在堆上创建的新对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br>System.out.println(str3 == str5);<span class="hljs-comment">//true</span><br>System.out.println(str4 == str5);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<h2 id="yqKHg">Exception和Error</h2>

<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/Exception%E5%92%8CError.png" srcset="/img/loading.gif" lazyload alt="Exception和Error"></p>
<h3 id="WyNGk">区别</h3>

<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><p><strong>Exception</strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p>
</li>
<li><p><strong>Error</strong>：<code>Error</code> 属于程序无法处理的错误 ，<del>我们没办法通过 ~~&#96;</del>catch<del>&#96;</del> 来进行捕获~~不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
</li>
</ul>
<h3 id="gHxJC">checked Exception和unchecked Exception的区别</h3>

<p><strong>Checked Exception</strong>即受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被catch或者throws关键字处理的话，就没办法通过编译。</p>
<p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException…</p>
<p><strong>Unchecked Exception</strong>即<strong>不受检查异常</strong>，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p>RuntimeException 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul>
<li>NullPointerException(空指针错误)</li>
<li>IllegalArgumentException(参数错误比如方法入参类型错误)</li>
<li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li>
<li>ArrayIndexOutOfBoundsException（数组越界错误）</li>
<li>ClassCastException（类型转换错误）</li>
<li>ArithmeticException（算术错误）</li>
<li>SecurityException（安全错误比如权限不够）</li>
<li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li>
</ul>
<h3 id="qOPQF">finally中的代码一定会执行吗？</h3>
不一定的！在某些情况下，finally 中的代码不会被执行。

<p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>    <span class="hljs-comment">// 终止当前正在运行的Java虚拟机</span><br>    System.exit(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Try to do something<br>Catch Exception -&gt; RuntimeException<br></code></pre></td></tr></table></figure>

<p>另外，在以下 2 种特殊情况下，finally块的代码也不会被执行：</p>
<ol>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<h2 id="ZRSXT">泛型</h2>
泛型（通过类型擦除实现）允许在定义类或接口的时候使用类型参数，声明的类型参数在使用的时候用具体的类型来替换。

<p>好处：</p>
<p>1.方便：例如定义Integer和String的List，不使用泛型，则需定义两个List<Integer>和List<String>，使用泛型则只需定义一个List<T></T></String></Integer></p>
<p>2.安全：没有泛型的使用，使用Object实现的类型转换会在运行时进行检查，类型转换出错，整个程序挂掉。使用泛型，则会在编译器进行检查，提高代码的安全性。</p>
<p>类型擦除：是Java处理泛型的一种方式，从泛型类型中擦除类型参数的相关信息，并在必要的时候添加类型检查和类型转换的方法。简单理解为，将泛型Java代码转换为普通Java代码。</p>
<h4 id="TklUq">泛型使用方式</h4>

<p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>
<p>1.泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//实例化泛型类</span><br>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure>

<p>2.泛型接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//实现泛型接口，不指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//实现泛型接口，指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3.泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; E &gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">( E[] inputArray )</span><br>&#123;<br>     <span class="hljs-keyword">for</span> ( E element : inputArray )&#123;<br>        System.out.printf( <span class="hljs-string">&quot;%s &quot;</span>, element );<br>     &#125;<br>     System.out.println();<br>&#125;<br><br><span class="hljs-comment">// 创建不同类型数组：Integer, Double 和 Character</span><br>Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>String[] stringArray = &#123; <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br>printArray( intArray  );<br>printArray( stringArray  );<br></code></pre></td></tr></table></figure>

<h2 id="XVX2u">反射</h2>
反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有属性和方法。

<p>Java的反射可以：</p>
<ol>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时任意调用一个对象的方法</li>
<li>在运行时构造任意一个类的对象</li>
</ol>
<p>反射的好处就是可以提升程序的灵活性和扩展性，比较容易在运行期干很多事情。但是他带来的问题更多，主要由以下几个：</p>
<ol>
<li>代码可读性低及可维护性</li>
<li>反射代码执行的性能低</li>
<li>反射破坏了封装性</li>
</ol>
<p>所以，我们应该在业务代码中应该尽量避免使用反射。但是，作为一个合格的ava开发，也要能读懂中间件、框架中的反射代码。在有些场景下，要知道可以使用反射解决部分问题。</p>
<h3 id="phzBG">反射和class的关系</h3>
Java的Class类是java反射机制的基础，通过Class类我们可以获得关于一个类的相关信息

<p>java.lang.Class是一个比较特殊的类，它用于封装被装入到VM中的类（包括类和接口)的信息。当一个类或接口被装入到JVM时便会产生一个与之关联的java.lang.Class对象，可以通过这个Class对象对被装入类的详细信息进行访问。</p>
<p>虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的<Class>对象是否已经加载。如果没有加载，JVM就会根据类名查找.class.文件，并将其Class对象载入。</Class></p>
<h3 id="cQeis">反射为什么慢？</h3>

<ol>
<li><p>由于反射涉及动态解析的类型，因此不能执行某些java虚拟机优化，如JIT优化。</p>
</li>
<li><p>在使用反射时，参数需要包装(boxing)成Object()类型，但是真正方法执行的时候，又需要再拆包(unboxing)成真正的类型，这些动作不仅消耗时间，而且过程中也会产生很多对象，对象一多就容易导致GC，GC也会导致应用变慢。</p>
</li>
<li><p>反射调用方法时会从方法数组中遍历查找，并且会检查可见性。这些动作都是耗时的。</p>
</li>
<li><p>不仅方法的可见性要做检查，参数也需要做很多额外的检查。</p>
</li>
</ol>
<h2 id="iNiGN">序列化和反序列化</h2>
如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。

<p>简单来说：</p>
<ul>
<li><p><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</p>
</li>
<li><p><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</p>
</li>
</ul>
<h3 id="sbsE2">序列化协议在TCP/IP4层模型的哪一层？</h3>

<p><img src="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/tcp4%E5%B1%82%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="tcp4层模型"></p>
<p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p>
<p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议应用层的一部分。</p>
<p>另外，用于序列化和反序列化的类必须实现 Serializable 接口，对象中如果有属性不想被序列化，使用 transient 修饰。</p>
<h2 id="YwQSn">I/O</h2>

<p> IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><p><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
</li>
<li><p><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
</li>
</ul>
<h3 id="UaN6B">字节流</h3>
<h4 id="K6u6l">InputStream</h4>
InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。

<p>FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Number of remaining bytes:&quot;</span><br>            + fis.available());<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fis.skip(<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">Number of remaining bytes:11<br>The actual number of bytes skipped:2<br>The content read from file:JavaGuide<br></code></pre></td></tr></table></figure>

<p>不过，一般我们是不会直接单独使用 FileInputStream，通常会配合BufferedInputStream（字节缓冲输入流，后文会讲到）来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br><span class="hljs-comment">// 读取文件的内容并复制到 String 对象中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufferedInputStream.readAllBytes());<br>System.out.println(result);<br></code></pre></td></tr></table></figure>

<h4 id="ZzClQ">OutputStream</h4>
OutputStream用于将数据（字节信息）写入到目的地（通常是文件），java.io.OutputStream抽象类是所有字节输出流的父类。

<p>FileOutputStream是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-string">&quot;JavaGuide&quot;</span>.getBytes();<br>    output.write(array);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类似于 FileInputStream，FileOutputStream 通常也会配合 BufferedOutputStream（字节缓冲输出流，后文会讲到）来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fileOutputStream)<br></code></pre></td></tr></table></figure>

<h3 id="MpbAx">字符流</h3>

<p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>个人认为主要有两点原因：</p>
<ul>
<li><p>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</p>
</li>
<li><p>如果我们不知道编码类型就很容易出现乱码问题</p>
</li>
</ul>
<p>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>
<h4 id="ok7Ye">Reader</h4>
Reader用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是所有字符输入流的父类。

<p>Reader用于读取文本，InputStream 用于读取原始字节。</p>
<p>InputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节流转换为字符流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于读取字符文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStreamReader</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);) &#123;<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fileReader.skip(<span class="hljs-number">3</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="MziG5">Writer</h4>
Writer用于将数据（字符信息）写入到目的地（通常是文件），java.io.Writer抽象类是所有字符输出流的父类。

<p>OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装，可以直接将字符写入到文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符流转换为字节流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于写入字符到文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OutputStreamWriter</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Writer</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>    output.write(<span class="hljs-string">&quot;你好，我是Guide。&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="mSWQU">字节缓冲流</h3>
IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。

<p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>
<p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。 如果是调用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</p>
<h3 id="c4Y9J">BufferedInputStream</h3>

<p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p>
<p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 <code>BufferedInputStream</code> 源码即可得到这个结论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br>    <span class="hljs-comment">// 内部缓冲区数组</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">byte</span> buf[];<br>    <span class="hljs-comment">// 缓冲区的默认大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>;<br>    <span class="hljs-comment">// 使用默认的缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>    &#125;<br>    <span class="hljs-comment">// 自定义缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>        &#125;<br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>缓冲区的大小默认为<strong>8192</strong> 字节，当然了，你也可以通过 BufferedInputStream(InputStream in, int size)这个构造方法来指定缓冲区的大小。</p>
<h3 id="LD0oA">BufferedOutputStream</h3>

<p><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))) &#123;<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-string">&quot;JavaGuide&quot;</span>.getBytes();<br>    bos.write(array);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类似于BufferedInputStream ，BufferedOutputStream 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <strong>8192</strong> 字节。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%8A%AA%E5%8A%9B%E6%88%90%E4%B8%BA%E7%89%9B%E9%A9%AC/" class="category-chain-item">努力成为牛马</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/" class="print-no-link">#面试</a>
      
        <a href="/tags/JAVA/" class="print-no-link">#JAVA</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java面试——基础篇</div>
      <div>https://blog.guxiang.lol/2024/10/10/Java面试——基础篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>柴勇玛喜达</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年10月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/10/10/SpringBoot+Vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/" title="SpringBoot+Vue3项目实战">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SpringBoot+Vue3项目实战</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94SpringBoot%E7%AF%87/" title="Java面试——SpringBoot篇">
                        <span class="hidden-mobile">Java面试——SpringBoot篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://blog.guxiang.lol/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/';
          this.page.identifier = '/2024/10/10/Java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("10/09/2024 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "🚀 for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
      document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" + snum + "&nbspsec";
  }  //此次自定义显示内容
  setInterval("createtime()",250);
  </script>
</div>

<div>
  
</div>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicRibbon.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/snowflake.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/love.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
